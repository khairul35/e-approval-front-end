{"ast":null,"code":"import { toRaw, shallowRef, watchEffect, watch } from 'vue';\nimport { convertChildrenToData } from '../utils/legacyUtil';\n/**\n * Parse `children` to `options` if `options` is not provided.\n * Then flatten the `options`.\n */\nexport default function useOptions(options, children, fieldNames) {\n  var mergedOptions = shallowRef();\n  var valueOptions = shallowRef();\n  var labelOptions = shallowRef();\n  var tempMergedOptions = shallowRef([]);\n  watch([options, children], function () {\n    if (options.value) {\n      tempMergedOptions.value = toRaw(options.value).slice();\n    } else {\n      tempMergedOptions.value = convertChildrenToData(children.value);\n    }\n  }, {\n    immediate: true,\n    deep: true\n  });\n  watchEffect(function () {\n    var newOptions = tempMergedOptions.value;\n    var newValueOptions = new Map();\n    var newLabelOptions = new Map();\n    var fieldNamesValue = fieldNames.value;\n    function dig(optionList) {\n      var isChildren = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // for loop to speed up collection speed\n      for (var i = 0; i < optionList.length; i += 1) {\n        var option = optionList[i];\n        if (!option[fieldNamesValue.options] || isChildren) {\n          newValueOptions.set(option[fieldNamesValue.value], option);\n          newLabelOptions.set(option[fieldNamesValue.label], option);\n        } else {\n          dig(option[fieldNamesValue.options], true);\n        }\n      }\n    }\n    dig(newOptions);\n    mergedOptions.value = newOptions;\n    valueOptions.value = newValueOptions;\n    labelOptions.value = newLabelOptions;\n  });\n  return {\n    options: mergedOptions,\n    valueOptions: valueOptions,\n    labelOptions: labelOptions\n  };\n}","map":{"version":3,"names":["toRaw","shallowRef","watchEffect","watch","convertChildrenToData","useOptions","options","children","fieldNames","mergedOptions","valueOptions","labelOptions","tempMergedOptions","value","slice","immediate","deep","newOptions","newValueOptions","Map","newLabelOptions","fieldNamesValue","dig","optionList","isChildren","arguments","length","undefined","i","option","set","label"],"sources":["/Users/dev/e-approver/node_modules/ant-design-vue/es/vc-select/hooks/useOptions.js"],"sourcesContent":["import { toRaw, shallowRef, watchEffect, watch } from 'vue';\nimport { convertChildrenToData } from '../utils/legacyUtil';\n/**\n * Parse `children` to `options` if `options` is not provided.\n * Then flatten the `options`.\n */\nexport default function useOptions(options, children, fieldNames) {\n  var mergedOptions = shallowRef();\n  var valueOptions = shallowRef();\n  var labelOptions = shallowRef();\n  var tempMergedOptions = shallowRef([]);\n  watch([options, children], function () {\n    if (options.value) {\n      tempMergedOptions.value = toRaw(options.value).slice();\n    } else {\n      tempMergedOptions.value = convertChildrenToData(children.value);\n    }\n  }, {\n    immediate: true,\n    deep: true\n  });\n  watchEffect(function () {\n    var newOptions = tempMergedOptions.value;\n    var newValueOptions = new Map();\n    var newLabelOptions = new Map();\n    var fieldNamesValue = fieldNames.value;\n    function dig(optionList) {\n      var isChildren = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // for loop to speed up collection speed\n      for (var i = 0; i < optionList.length; i += 1) {\n        var option = optionList[i];\n        if (!option[fieldNamesValue.options] || isChildren) {\n          newValueOptions.set(option[fieldNamesValue.value], option);\n          newLabelOptions.set(option[fieldNamesValue.label], option);\n        } else {\n          dig(option[fieldNamesValue.options], true);\n        }\n      }\n    }\n    dig(newOptions);\n    mergedOptions.value = newOptions;\n    valueOptions.value = newValueOptions;\n    labelOptions.value = newLabelOptions;\n  });\n  return {\n    options: mergedOptions,\n    valueOptions: valueOptions,\n    labelOptions: labelOptions\n  };\n}"],"mappings":"AAAA,SAASA,KAAK,EAAEC,UAAU,EAAEC,WAAW,EAAEC,KAAK,QAAQ,KAAK;AAC3D,SAASC,qBAAqB,QAAQ,qBAAqB;AAC3D;AACA;AACA;AACA;AACA,eAAe,SAASC,UAAUA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,UAAU,EAAE;EAChE,IAAIC,aAAa,GAAGR,UAAU,EAAE;EAChC,IAAIS,YAAY,GAAGT,UAAU,EAAE;EAC/B,IAAIU,YAAY,GAAGV,UAAU,EAAE;EAC/B,IAAIW,iBAAiB,GAAGX,UAAU,CAAC,EAAE,CAAC;EACtCE,KAAK,CAAC,CAACG,OAAO,EAAEC,QAAQ,CAAC,EAAE,YAAY;IACrC,IAAID,OAAO,CAACO,KAAK,EAAE;MACjBD,iBAAiB,CAACC,KAAK,GAAGb,KAAK,CAACM,OAAO,CAACO,KAAK,CAAC,CAACC,KAAK,EAAE;IACxD,CAAC,MAAM;MACLF,iBAAiB,CAACC,KAAK,GAAGT,qBAAqB,CAACG,QAAQ,CAACM,KAAK,CAAC;IACjE;EACF,CAAC,EAAE;IACDE,SAAS,EAAE,IAAI;IACfC,IAAI,EAAE;EACR,CAAC,CAAC;EACFd,WAAW,CAAC,YAAY;IACtB,IAAIe,UAAU,GAAGL,iBAAiB,CAACC,KAAK;IACxC,IAAIK,eAAe,GAAG,IAAIC,GAAG,EAAE;IAC/B,IAAIC,eAAe,GAAG,IAAID,GAAG,EAAE;IAC/B,IAAIE,eAAe,GAAGb,UAAU,CAACK,KAAK;IACtC,SAASS,GAAGA,CAACC,UAAU,EAAE;MACvB,IAAIC,UAAU,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;MAC1F;MACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,UAAU,CAACG,MAAM,EAAEE,CAAC,IAAI,CAAC,EAAE;QAC7C,IAAIC,MAAM,GAAGN,UAAU,CAACK,CAAC,CAAC;QAC1B,IAAI,CAACC,MAAM,CAACR,eAAe,CAACf,OAAO,CAAC,IAAIkB,UAAU,EAAE;UAClDN,eAAe,CAACY,GAAG,CAACD,MAAM,CAACR,eAAe,CAACR,KAAK,CAAC,EAAEgB,MAAM,CAAC;UAC1DT,eAAe,CAACU,GAAG,CAACD,MAAM,CAACR,eAAe,CAACU,KAAK,CAAC,EAAEF,MAAM,CAAC;QAC5D,CAAC,MAAM;UACLP,GAAG,CAACO,MAAM,CAACR,eAAe,CAACf,OAAO,CAAC,EAAE,IAAI,CAAC;QAC5C;MACF;IACF;IACAgB,GAAG,CAACL,UAAU,CAAC;IACfR,aAAa,CAACI,KAAK,GAAGI,UAAU;IAChCP,YAAY,CAACG,KAAK,GAAGK,eAAe;IACpCP,YAAY,CAACE,KAAK,GAAGO,eAAe;EACtC,CAAC,CAAC;EACF,OAAO;IACLd,OAAO,EAAEG,aAAa;IACtBC,YAAY,EAAEA,YAAY;IAC1BC,YAAY,EAAEA;EAChB,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}