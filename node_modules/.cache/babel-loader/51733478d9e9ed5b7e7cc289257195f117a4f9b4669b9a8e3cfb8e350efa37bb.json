{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nvar _excluded = [\"prefixCls\", \"min\", \"max\", \"step\", \"defaultValue\", \"value\", \"disabled\", \"readonly\", \"keyboard\", \"controls\", \"autofocus\", \"stringMode\", \"parser\", \"formatter\", \"precision\", \"decimalSeparator\", \"onChange\", \"onInput\", \"onPressEnter\", \"onStep\", \"lazy\", \"class\", \"style\"];\nimport { createVNode as _createVNode, resolveDirective as _resolveDirective } from \"vue\";\nimport getMiniDecimal, { toFixed } from './utils/MiniDecimal';\nimport StepHandler from './StepHandler';\nimport { getNumberPrecision, num2str, validateNumber } from './utils/numberUtil';\nimport useCursor from './hooks/useCursor';\nimport useFrame from './hooks/useFrame';\nimport { watch, computed, ref, defineComponent } from 'vue';\nimport KeyCode from '../../_util/KeyCode';\nimport classNames from '../../_util/classNames';\n/**\n * We support `stringMode` which need handle correct type when user call in onChange\n * format max or min value\n * 1. if isInvalid return null\n * 2. if precision is undefined, return decimal\n * 3. format with precision\n *    I. if max > 0, round down with precision. Example: max= 3.5, precision=0  afterFormat: 3\n *    II. if max < 0, round up with precision. Example: max= -3.5, precision=0  afterFormat: -4\n *    III. if min > 0, round up with precision. Example: min= 3.5, precision=0  afterFormat: 4\n *    IV. if min < 0, round down with precision. Example: max= -3.5, precision=0  afterFormat: -3\n */\nvar getDecimalValue = function getDecimalValue(stringMode, decimalValue) {\n  if (stringMode || decimalValue.isEmpty()) {\n    return decimalValue.toString();\n  }\n  return decimalValue.toNumber();\n};\nvar getDecimalIfValidate = function getDecimalIfValidate(value) {\n  var decimal = getMiniDecimal(value);\n  return decimal.isInvalidate() ? null : decimal;\n};\nexport var inputNumberProps = function inputNumberProps() {\n  return {\n    /** value will show as string */\n    stringMode: {\n      type: Boolean\n    },\n    defaultValue: {\n      type: [String, Number]\n    },\n    value: {\n      type: [String, Number]\n    },\n    prefixCls: {\n      type: String\n    },\n    min: {\n      type: [String, Number]\n    },\n    max: {\n      type: [String, Number]\n    },\n    step: {\n      type: [String, Number],\n      default: 1\n    },\n    tabindex: {\n      type: Number\n    },\n    controls: {\n      type: Boolean,\n      default: true\n    },\n    readonly: {\n      type: Boolean\n    },\n    disabled: {\n      type: Boolean\n    },\n    autofocus: {\n      type: Boolean\n    },\n    keyboard: {\n      type: Boolean,\n      default: true\n    },\n    /** Parse display value to validate number */\n    parser: {\n      type: Function\n    },\n    /** Transform `value` to display value show in input */\n    formatter: {\n      type: Function\n    },\n    /** Syntactic sugar of `formatter`. Config precision of display. */\n    precision: {\n      type: Number\n    },\n    /** Syntactic sugar of `formatter`. Config decimal separator of display. */\n    decimalSeparator: {\n      type: String\n    },\n    onInput: {\n      type: Function\n    },\n    onChange: {\n      type: Function\n    },\n    onPressEnter: {\n      type: Function\n    },\n    onStep: {\n      type: Function\n    },\n    onBlur: {\n      type: Function\n    },\n    onFocus: {\n      type: Function\n    }\n  };\n};\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'InnerInputNumber',\n  inheritAttrs: false,\n  props: _objectSpread(_objectSpread({}, inputNumberProps()), {}, {\n    lazy: Boolean\n  }),\n  slots: ['upHandler', 'downHandler'],\n  setup: function setup(props, _ref) {\n    var attrs = _ref.attrs,\n      slots = _ref.slots,\n      emit = _ref.emit,\n      expose = _ref.expose;\n    var inputRef = ref();\n    var focus = ref(false);\n    var userTypingRef = ref(false);\n    var compositionRef = ref(false);\n    var decimalValue = ref(getMiniDecimal(props.value));\n    function setUncontrolledDecimalValue(newDecimal) {\n      if (props.value === undefined) {\n        decimalValue.value = newDecimal;\n      }\n    }\n    // ====================== Parser & Formatter ======================\n    /**\n     * `precision` is used for formatter & onChange.\n     * It will auto generate by `value` & `step`.\n     * But it will not block user typing.\n     *\n     * Note: Auto generate `precision` is used for legacy logic.\n     * We should remove this since we already support high precision with BigInt.\n     *\n     * @param number  Provide which number should calculate precision\n     * @param userTyping  Change by user typing\n     */\n    var getPrecision = function getPrecision(numStr, userTyping) {\n      if (userTyping) {\n        return undefined;\n      }\n      if (props.precision >= 0) {\n        return props.precision;\n      }\n      return Math.max(getNumberPrecision(numStr), getNumberPrecision(props.step));\n    };\n    // >>> Parser\n    var mergedParser = function mergedParser(num) {\n      var numStr = String(num);\n      if (props.parser) {\n        return props.parser(numStr);\n      }\n      var parsedStr = numStr;\n      if (props.decimalSeparator) {\n        parsedStr = parsedStr.replace(props.decimalSeparator, '.');\n      }\n      // [Legacy] We still support auto convert `$ 123,456` to `123456`\n      return parsedStr.replace(/[^\\w.-]+/g, '');\n    };\n    // >>> Formatter\n    var inputValue = ref('');\n    var mergedFormatter = function mergedFormatter(number, userTyping) {\n      if (props.formatter) {\n        return props.formatter(number, {\n          userTyping: userTyping,\n          input: String(inputValue.value)\n        });\n      }\n      var str = typeof number === 'number' ? num2str(number) : number;\n      // User typing will not auto format with precision directly\n      if (!userTyping) {\n        var mergedPrecision = getPrecision(str, userTyping);\n        if (validateNumber(str) && (props.decimalSeparator || mergedPrecision >= 0)) {\n          // Separator\n          var separatorStr = props.decimalSeparator || '.';\n          str = toFixed(str, separatorStr, mergedPrecision);\n        }\n      }\n      return str;\n    };\n    // ========================== InputValue ==========================\n    /**\n     * Input text value control\n     *\n     * User can not update input content directly. It update with follow rules by priority:\n     *  1. controlled `value` changed\n     *    * [SPECIAL] Typing like `1.` should not immediately convert to `1`\n     *  2. User typing with format (not precision)\n     *  3. Blur or Enter trigger revalidate\n     */\n    var initValue = function () {\n      var initValue = props.value;\n      if (decimalValue.value.isInvalidate() && ['string', 'number'].includes(_typeof(initValue))) {\n        return Number.isNaN(initValue) ? '' : initValue;\n      }\n      return mergedFormatter(decimalValue.value.toString(), false);\n    }();\n    inputValue.value = initValue;\n    // Should always be string\n    function setInputValue(newValue, userTyping) {\n      inputValue.value = mergedFormatter(\n      // Invalidate number is sometime passed by external control, we should let it go\n      // Otherwise is controlled by internal interactive logic which check by userTyping\n      // You can ref 'show limited value when input is not focused' test for more info.\n      newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping);\n    }\n    // >>> Max & Min limit\n    var maxDecimal = computed(function () {\n      return getDecimalIfValidate(props.max);\n    });\n    var minDecimal = computed(function () {\n      return getDecimalIfValidate(props.min);\n    });\n    var upDisabled = computed(function () {\n      if (!maxDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {\n        return false;\n      }\n      return maxDecimal.value.lessEquals(decimalValue.value);\n    });\n    var downDisabled = computed(function () {\n      if (!minDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {\n        return false;\n      }\n      return decimalValue.value.lessEquals(minDecimal.value);\n    });\n    // Cursor controller\n    var _useCursor = useCursor(inputRef, focus),\n      _useCursor2 = _slicedToArray(_useCursor, 2),\n      recordCursor = _useCursor2[0],\n      restoreCursor = _useCursor2[1];\n    // ============================= Data =============================\n    /**\n     * Find target value closet within range.\n     * e.g. [11, 28]:\n     *    3  => 11\n     *    23 => 23\n     *    99 => 28\n     */\n    var getRangeValue = function getRangeValue(target) {\n      // target > max\n      if (maxDecimal.value && !target.lessEquals(maxDecimal.value)) {\n        return maxDecimal.value;\n      }\n      // target < min\n      if (minDecimal.value && !minDecimal.value.lessEquals(target)) {\n        return minDecimal.value;\n      }\n      return null;\n    };\n    /**\n     * Check value is in [min, max] range\n     */\n    var isInRange = function isInRange(target) {\n      return !getRangeValue(target);\n    };\n    /**\n     * Trigger `onChange` if value validated and not equals of origin.\n     * Return the value that re-align in range.\n     */\n    var triggerValueUpdate = function triggerValueUpdate(newValue, userTyping) {\n      var updateValue = newValue;\n      var isRangeValidate = isInRange(updateValue) || updateValue.isEmpty();\n      // Skip align value when trigger value is empty.\n      // We just trigger onChange(null)\n      // This should not block user typing\n      if (!updateValue.isEmpty() && !userTyping) {\n        // Revert value in range if needed\n        updateValue = getRangeValue(updateValue) || updateValue;\n        isRangeValidate = true;\n      }\n      if (!props.readonly && !props.disabled && isRangeValidate) {\n        var numStr = updateValue.toString();\n        var mergedPrecision = getPrecision(numStr, userTyping);\n        if (mergedPrecision >= 0) {\n          updateValue = getMiniDecimal(toFixed(numStr, '.', mergedPrecision));\n        }\n        // Trigger event\n        if (!updateValue.equals(decimalValue.value)) {\n          var _props$onChange;\n          setUncontrolledDecimalValue(updateValue);\n          (_props$onChange = props.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props, updateValue.isEmpty() ? null : getDecimalValue(props.stringMode, updateValue));\n          // Reformat input if value is not controlled\n          if (props.value === undefined) {\n            setInputValue(updateValue, userTyping);\n          }\n        }\n        return updateValue;\n      }\n      return decimalValue.value;\n    };\n    // ========================== User Input ==========================\n    var onNextPromise = useFrame();\n    // >>> Collect input value\n    var collectInputValue = function collectInputValue(inputStr) {\n      var _props$onInput;\n      recordCursor();\n      // Update inputValue incase input can not parse as number\n      inputValue.value = inputStr;\n      // Parse number\n      if (!compositionRef.value) {\n        var finalValue = mergedParser(inputStr);\n        var finalDecimal = getMiniDecimal(finalValue);\n        if (!finalDecimal.isNaN()) {\n          triggerValueUpdate(finalDecimal, true);\n        }\n      }\n      // Trigger onInput later to let user customize value if they want do handle something after onChange\n      (_props$onInput = props.onInput) === null || _props$onInput === void 0 ? void 0 : _props$onInput.call(props, inputStr);\n      // optimize for chinese input experience\n      // https://github.com/ant-design/ant-design/issues/8196\n      onNextPromise(function () {\n        var nextInputStr = inputStr;\n        if (!props.parser) {\n          nextInputStr = inputStr.replace(/。/g, '.');\n        }\n        if (nextInputStr !== inputStr) {\n          collectInputValue(nextInputStr);\n        }\n      });\n    };\n    // >>> Composition\n    var onCompositionStart = function onCompositionStart() {\n      compositionRef.value = true;\n    };\n    var onCompositionEnd = function onCompositionEnd() {\n      compositionRef.value = false;\n      collectInputValue(inputRef.value.value);\n    };\n    // >>> Input\n    var onInternalInput = function onInternalInput(e) {\n      collectInputValue(e.target.value);\n    };\n    // ============================= Step =============================\n    var onInternalStep = function onInternalStep(up) {\n      var _props$onStep, _inputRef$value;\n      // Ignore step since out of range\n      if (up && upDisabled.value || !up && downDisabled.value) {\n        return;\n      }\n      // Clear typing status since it may caused by up & down key.\n      // We should sync with input value.\n      userTypingRef.value = false;\n      var stepDecimal = getMiniDecimal(props.step);\n      if (!up) {\n        stepDecimal = stepDecimal.negate();\n      }\n      var target = (decimalValue.value || getMiniDecimal(0)).add(stepDecimal.toString());\n      var updatedValue = triggerValueUpdate(target, false);\n      (_props$onStep = props.onStep) === null || _props$onStep === void 0 ? void 0 : _props$onStep.call(props, getDecimalValue(props.stringMode, updatedValue), {\n        offset: props.step,\n        type: up ? 'up' : 'down'\n      });\n      (_inputRef$value = inputRef.value) === null || _inputRef$value === void 0 ? void 0 : _inputRef$value.focus();\n    };\n    // ============================ Flush =============================\n    /**\n     * Flush current input content to trigger value change & re-formatter input if needed\n     */\n    var flushInputValue = function flushInputValue(userTyping) {\n      var parsedValue = getMiniDecimal(mergedParser(inputValue.value));\n      var formatValue = parsedValue;\n      if (!parsedValue.isNaN()) {\n        // Only validate value or empty value can be re-fill to inputValue\n        // Reassign the formatValue within ranged of trigger control\n        formatValue = triggerValueUpdate(parsedValue, userTyping);\n      } else {\n        formatValue = decimalValue.value;\n      }\n      if (props.value !== undefined) {\n        // Reset back with controlled value first\n        setInputValue(decimalValue.value, false);\n      } else if (!formatValue.isNaN()) {\n        // Reset input back since no validate value\n        setInputValue(formatValue, false);\n      }\n    };\n    var onKeyDown = function onKeyDown(event) {\n      var which = event.which;\n      userTypingRef.value = true;\n      if (which === KeyCode.ENTER) {\n        var _props$onPressEnter;\n        if (!compositionRef.value) {\n          userTypingRef.value = false;\n        }\n        flushInputValue(false);\n        (_props$onPressEnter = props.onPressEnter) === null || _props$onPressEnter === void 0 ? void 0 : _props$onPressEnter.call(props, event);\n      }\n      if (props.keyboard === false) {\n        return;\n      }\n      // Do step\n      if (!compositionRef.value && [KeyCode.UP, KeyCode.DOWN].includes(which)) {\n        onInternalStep(KeyCode.UP === which);\n        event.preventDefault();\n      }\n    };\n    var onKeyUp = function onKeyUp() {\n      userTypingRef.value = false;\n    };\n    // >>> Focus & Blur\n    var onBlur = function onBlur(e) {\n      flushInputValue(false);\n      focus.value = false;\n      userTypingRef.value = false;\n      emit('blur', e);\n    };\n    // ========================== Controlled ==========================\n    // Input by precision\n    watch(function () {\n      return props.precision;\n    }, function () {\n      if (!decimalValue.value.isInvalidate()) {\n        setInputValue(decimalValue.value, false);\n      }\n    }, {\n      flush: 'post'\n    });\n    // Input by value\n    watch(function () {\n      return props.value;\n    }, function () {\n      var newValue = getMiniDecimal(props.value);\n      decimalValue.value = newValue;\n      var currentParsedValue = getMiniDecimal(mergedParser(inputValue.value));\n      // When user typing from `1.2` to `1.`, we should not convert to `1` immediately.\n      // But let it go if user set `formatter`\n      if (!newValue.equals(currentParsedValue) || !userTypingRef.value || props.formatter) {\n        // Update value as effect\n        setInputValue(newValue, userTypingRef.value);\n      }\n    }, {\n      flush: 'post'\n    });\n    // ============================ Cursor ============================\n    watch(inputValue, function () {\n      if (props.formatter) {\n        restoreCursor();\n      }\n    }, {\n      flush: 'post'\n    });\n    watch(function () {\n      return props.disabled;\n    }, function (val) {\n      if (val) {\n        focus.value = false;\n      }\n    });\n    expose({\n      focus: function focus() {\n        var _inputRef$value2;\n        (_inputRef$value2 = inputRef.value) === null || _inputRef$value2 === void 0 ? void 0 : _inputRef$value2.focus();\n      },\n      blur: function blur() {\n        var _inputRef$value3;\n        (_inputRef$value3 = inputRef.value) === null || _inputRef$value3 === void 0 ? void 0 : _inputRef$value3.blur();\n      }\n    });\n    return function () {\n      var _classNames;\n      var _attrs$props = _objectSpread(_objectSpread({}, attrs), props),\n        _attrs$props$prefixCl = _attrs$props.prefixCls,\n        prefixCls = _attrs$props$prefixCl === void 0 ? 'rc-input-number' : _attrs$props$prefixCl,\n        min = _attrs$props.min,\n        max = _attrs$props.max,\n        _attrs$props$step = _attrs$props.step,\n        step = _attrs$props$step === void 0 ? 1 : _attrs$props$step,\n        defaultValue = _attrs$props.defaultValue,\n        value = _attrs$props.value,\n        disabled = _attrs$props.disabled,\n        readonly = _attrs$props.readonly,\n        keyboard = _attrs$props.keyboard,\n        _attrs$props$controls = _attrs$props.controls,\n        controls = _attrs$props$controls === void 0 ? true : _attrs$props$controls,\n        autofocus = _attrs$props.autofocus,\n        stringMode = _attrs$props.stringMode,\n        parser = _attrs$props.parser,\n        formatter = _attrs$props.formatter,\n        precision = _attrs$props.precision,\n        decimalSeparator = _attrs$props.decimalSeparator,\n        onChange = _attrs$props.onChange,\n        onInput = _attrs$props.onInput,\n        onPressEnter = _attrs$props.onPressEnter,\n        onStep = _attrs$props.onStep,\n        lazy = _attrs$props.lazy,\n        className = _attrs$props.class,\n        style = _attrs$props.style,\n        inputProps = _objectWithoutProperties(_attrs$props, _excluded);\n      var upHandler = slots.upHandler,\n        downHandler = slots.downHandler;\n      var inputClassName = \"\".concat(prefixCls, \"-input\");\n      var eventProps = {};\n      if (lazy) {\n        eventProps.onChange = onInternalInput;\n      } else {\n        eventProps.onInput = onInternalInput;\n      }\n      return _createVNode(\"div\", {\n        \"class\": classNames(prefixCls, className, (_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-focused\"), focus.value), _defineProperty(_classNames, \"\".concat(prefixCls, \"-disabled\"), disabled), _defineProperty(_classNames, \"\".concat(prefixCls, \"-readonly\"), readonly), _defineProperty(_classNames, \"\".concat(prefixCls, \"-not-a-number\"), decimalValue.value.isNaN()), _defineProperty(_classNames, \"\".concat(prefixCls, \"-out-of-range\"), !decimalValue.value.isInvalidate() && !isInRange(decimalValue.value)), _classNames)),\n        \"style\": style,\n        \"onKeydown\": onKeyDown,\n        \"onKeyup\": onKeyUp\n      }, [controls && _createVNode(StepHandler, {\n        \"prefixCls\": prefixCls,\n        \"upDisabled\": upDisabled.value,\n        \"downDisabled\": downDisabled.value,\n        \"onStep\": onInternalStep\n      }, {\n        upNode: upHandler,\n        downNode: downHandler\n      }), _createVNode(\"div\", {\n        \"class\": \"\".concat(inputClassName, \"-wrap\")\n      }, [_createVNode(\"input\", _objectSpread(_objectSpread(_objectSpread({\n        \"autofocus\": autofocus,\n        \"autocomplete\": \"off\",\n        \"role\": \"spinbutton\",\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-valuenow\": decimalValue.value.isInvalidate() ? null : decimalValue.value.toString(),\n        \"step\": step\n      }, inputProps), {}, {\n        \"ref\": inputRef,\n        \"class\": inputClassName,\n        \"value\": inputValue.value,\n        \"disabled\": disabled,\n        \"readonly\": readonly,\n        \"onFocus\": function onFocus(e) {\n          focus.value = true;\n          emit('focus', e);\n        }\n      }, eventProps), {}, {\n        \"onBlur\": onBlur,\n        \"onCompositionstart\": onCompositionStart,\n        \"onCompositionend\": onCompositionEnd\n      }), null)])]);\n    };\n  }\n});","map":{"version":3,"names":["_defineProperty","_objectWithoutProperties","_slicedToArray","_typeof","_objectSpread","_excluded","createVNode","_createVNode","resolveDirective","_resolveDirective","getMiniDecimal","toFixed","StepHandler","getNumberPrecision","num2str","validateNumber","useCursor","useFrame","watch","computed","ref","defineComponent","KeyCode","classNames","getDecimalValue","stringMode","decimalValue","isEmpty","toString","toNumber","getDecimalIfValidate","value","decimal","isInvalidate","inputNumberProps","type","Boolean","defaultValue","String","Number","prefixCls","min","max","step","default","tabindex","controls","readonly","disabled","autofocus","keyboard","parser","Function","formatter","precision","decimalSeparator","onInput","onChange","onPressEnter","onStep","onBlur","onFocus","compatConfig","MODE","name","inheritAttrs","props","lazy","slots","setup","_ref","attrs","emit","expose","inputRef","focus","userTypingRef","compositionRef","setUncontrolledDecimalValue","newDecimal","undefined","getPrecision","numStr","userTyping","Math","mergedParser","num","parsedStr","replace","inputValue","mergedFormatter","number","input","str","mergedPrecision","separatorStr","initValue","includes","isNaN","setInputValue","newValue","maxDecimal","minDecimal","upDisabled","lessEquals","downDisabled","_useCursor","_useCursor2","recordCursor","restoreCursor","getRangeValue","target","isInRange","triggerValueUpdate","updateValue","isRangeValidate","equals","_props$onChange","call","onNextPromise","collectInputValue","inputStr","_props$onInput","finalValue","finalDecimal","nextInputStr","onCompositionStart","onCompositionEnd","onInternalInput","e","onInternalStep","up","_props$onStep","_inputRef$value","stepDecimal","negate","add","updatedValue","offset","flushInputValue","parsedValue","formatValue","onKeyDown","event","which","ENTER","_props$onPressEnter","UP","DOWN","preventDefault","onKeyUp","flush","currentParsedValue","val","_inputRef$value2","blur","_inputRef$value3","_classNames","_attrs$props","_attrs$props$prefixCl","_attrs$props$step","_attrs$props$controls","className","class","style","inputProps","upHandler","downHandler","inputClassName","concat","eventProps","upNode","downNode"],"sources":["/Users/dev/e-approver/node_modules/ant-design-vue/es/input-number/src/InputNumber.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nvar _excluded = [\"prefixCls\", \"min\", \"max\", \"step\", \"defaultValue\", \"value\", \"disabled\", \"readonly\", \"keyboard\", \"controls\", \"autofocus\", \"stringMode\", \"parser\", \"formatter\", \"precision\", \"decimalSeparator\", \"onChange\", \"onInput\", \"onPressEnter\", \"onStep\", \"lazy\", \"class\", \"style\"];\nimport { createVNode as _createVNode, resolveDirective as _resolveDirective } from \"vue\";\nimport getMiniDecimal, { toFixed } from './utils/MiniDecimal';\nimport StepHandler from './StepHandler';\nimport { getNumberPrecision, num2str, validateNumber } from './utils/numberUtil';\nimport useCursor from './hooks/useCursor';\nimport useFrame from './hooks/useFrame';\nimport { watch, computed, ref, defineComponent } from 'vue';\nimport KeyCode from '../../_util/KeyCode';\nimport classNames from '../../_util/classNames';\n/**\n * We support `stringMode` which need handle correct type when user call in onChange\n * format max or min value\n * 1. if isInvalid return null\n * 2. if precision is undefined, return decimal\n * 3. format with precision\n *    I. if max > 0, round down with precision. Example: max= 3.5, precision=0  afterFormat: 3\n *    II. if max < 0, round up with precision. Example: max= -3.5, precision=0  afterFormat: -4\n *    III. if min > 0, round up with precision. Example: min= 3.5, precision=0  afterFormat: 4\n *    IV. if min < 0, round down with precision. Example: max= -3.5, precision=0  afterFormat: -3\n */\nvar getDecimalValue = function getDecimalValue(stringMode, decimalValue) {\n  if (stringMode || decimalValue.isEmpty()) {\n    return decimalValue.toString();\n  }\n  return decimalValue.toNumber();\n};\nvar getDecimalIfValidate = function getDecimalIfValidate(value) {\n  var decimal = getMiniDecimal(value);\n  return decimal.isInvalidate() ? null : decimal;\n};\nexport var inputNumberProps = function inputNumberProps() {\n  return {\n    /** value will show as string */\n    stringMode: {\n      type: Boolean\n    },\n    defaultValue: {\n      type: [String, Number]\n    },\n    value: {\n      type: [String, Number]\n    },\n    prefixCls: {\n      type: String\n    },\n    min: {\n      type: [String, Number]\n    },\n    max: {\n      type: [String, Number]\n    },\n    step: {\n      type: [String, Number],\n      default: 1\n    },\n    tabindex: {\n      type: Number\n    },\n    controls: {\n      type: Boolean,\n      default: true\n    },\n    readonly: {\n      type: Boolean\n    },\n    disabled: {\n      type: Boolean\n    },\n    autofocus: {\n      type: Boolean\n    },\n    keyboard: {\n      type: Boolean,\n      default: true\n    },\n    /** Parse display value to validate number */\n    parser: {\n      type: Function\n    },\n    /** Transform `value` to display value show in input */\n    formatter: {\n      type: Function\n    },\n    /** Syntactic sugar of `formatter`. Config precision of display. */\n    precision: {\n      type: Number\n    },\n    /** Syntactic sugar of `formatter`. Config decimal separator of display. */\n    decimalSeparator: {\n      type: String\n    },\n    onInput: {\n      type: Function\n    },\n    onChange: {\n      type: Function\n    },\n    onPressEnter: {\n      type: Function\n    },\n    onStep: {\n      type: Function\n    },\n    onBlur: {\n      type: Function\n    },\n    onFocus: {\n      type: Function\n    }\n  };\n};\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'InnerInputNumber',\n  inheritAttrs: false,\n  props: _objectSpread(_objectSpread({}, inputNumberProps()), {}, {\n    lazy: Boolean\n  }),\n  slots: ['upHandler', 'downHandler'],\n  setup: function setup(props, _ref) {\n    var attrs = _ref.attrs,\n      slots = _ref.slots,\n      emit = _ref.emit,\n      expose = _ref.expose;\n    var inputRef = ref();\n    var focus = ref(false);\n    var userTypingRef = ref(false);\n    var compositionRef = ref(false);\n    var decimalValue = ref(getMiniDecimal(props.value));\n    function setUncontrolledDecimalValue(newDecimal) {\n      if (props.value === undefined) {\n        decimalValue.value = newDecimal;\n      }\n    }\n    // ====================== Parser & Formatter ======================\n    /**\n     * `precision` is used for formatter & onChange.\n     * It will auto generate by `value` & `step`.\n     * But it will not block user typing.\n     *\n     * Note: Auto generate `precision` is used for legacy logic.\n     * We should remove this since we already support high precision with BigInt.\n     *\n     * @param number  Provide which number should calculate precision\n     * @param userTyping  Change by user typing\n     */\n    var getPrecision = function getPrecision(numStr, userTyping) {\n      if (userTyping) {\n        return undefined;\n      }\n      if (props.precision >= 0) {\n        return props.precision;\n      }\n      return Math.max(getNumberPrecision(numStr), getNumberPrecision(props.step));\n    };\n    // >>> Parser\n    var mergedParser = function mergedParser(num) {\n      var numStr = String(num);\n      if (props.parser) {\n        return props.parser(numStr);\n      }\n      var parsedStr = numStr;\n      if (props.decimalSeparator) {\n        parsedStr = parsedStr.replace(props.decimalSeparator, '.');\n      }\n      // [Legacy] We still support auto convert `$ 123,456` to `123456`\n      return parsedStr.replace(/[^\\w.-]+/g, '');\n    };\n    // >>> Formatter\n    var inputValue = ref('');\n    var mergedFormatter = function mergedFormatter(number, userTyping) {\n      if (props.formatter) {\n        return props.formatter(number, {\n          userTyping: userTyping,\n          input: String(inputValue.value)\n        });\n      }\n      var str = typeof number === 'number' ? num2str(number) : number;\n      // User typing will not auto format with precision directly\n      if (!userTyping) {\n        var mergedPrecision = getPrecision(str, userTyping);\n        if (validateNumber(str) && (props.decimalSeparator || mergedPrecision >= 0)) {\n          // Separator\n          var separatorStr = props.decimalSeparator || '.';\n          str = toFixed(str, separatorStr, mergedPrecision);\n        }\n      }\n      return str;\n    };\n    // ========================== InputValue ==========================\n    /**\n     * Input text value control\n     *\n     * User can not update input content directly. It update with follow rules by priority:\n     *  1. controlled `value` changed\n     *    * [SPECIAL] Typing like `1.` should not immediately convert to `1`\n     *  2. User typing with format (not precision)\n     *  3. Blur or Enter trigger revalidate\n     */\n    var initValue = function () {\n      var initValue = props.value;\n      if (decimalValue.value.isInvalidate() && ['string', 'number'].includes(_typeof(initValue))) {\n        return Number.isNaN(initValue) ? '' : initValue;\n      }\n      return mergedFormatter(decimalValue.value.toString(), false);\n    }();\n    inputValue.value = initValue;\n    // Should always be string\n    function setInputValue(newValue, userTyping) {\n      inputValue.value = mergedFormatter(\n      // Invalidate number is sometime passed by external control, we should let it go\n      // Otherwise is controlled by internal interactive logic which check by userTyping\n      // You can ref 'show limited value when input is not focused' test for more info.\n      newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping);\n    }\n    // >>> Max & Min limit\n    var maxDecimal = computed(function () {\n      return getDecimalIfValidate(props.max);\n    });\n    var minDecimal = computed(function () {\n      return getDecimalIfValidate(props.min);\n    });\n    var upDisabled = computed(function () {\n      if (!maxDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {\n        return false;\n      }\n      return maxDecimal.value.lessEquals(decimalValue.value);\n    });\n    var downDisabled = computed(function () {\n      if (!minDecimal.value || !decimalValue.value || decimalValue.value.isInvalidate()) {\n        return false;\n      }\n      return decimalValue.value.lessEquals(minDecimal.value);\n    });\n    // Cursor controller\n    var _useCursor = useCursor(inputRef, focus),\n      _useCursor2 = _slicedToArray(_useCursor, 2),\n      recordCursor = _useCursor2[0],\n      restoreCursor = _useCursor2[1];\n    // ============================= Data =============================\n    /**\n     * Find target value closet within range.\n     * e.g. [11, 28]:\n     *    3  => 11\n     *    23 => 23\n     *    99 => 28\n     */\n    var getRangeValue = function getRangeValue(target) {\n      // target > max\n      if (maxDecimal.value && !target.lessEquals(maxDecimal.value)) {\n        return maxDecimal.value;\n      }\n      // target < min\n      if (minDecimal.value && !minDecimal.value.lessEquals(target)) {\n        return minDecimal.value;\n      }\n      return null;\n    };\n    /**\n     * Check value is in [min, max] range\n     */\n    var isInRange = function isInRange(target) {\n      return !getRangeValue(target);\n    };\n    /**\n     * Trigger `onChange` if value validated and not equals of origin.\n     * Return the value that re-align in range.\n     */\n    var triggerValueUpdate = function triggerValueUpdate(newValue, userTyping) {\n      var updateValue = newValue;\n      var isRangeValidate = isInRange(updateValue) || updateValue.isEmpty();\n      // Skip align value when trigger value is empty.\n      // We just trigger onChange(null)\n      // This should not block user typing\n      if (!updateValue.isEmpty() && !userTyping) {\n        // Revert value in range if needed\n        updateValue = getRangeValue(updateValue) || updateValue;\n        isRangeValidate = true;\n      }\n      if (!props.readonly && !props.disabled && isRangeValidate) {\n        var numStr = updateValue.toString();\n        var mergedPrecision = getPrecision(numStr, userTyping);\n        if (mergedPrecision >= 0) {\n          updateValue = getMiniDecimal(toFixed(numStr, '.', mergedPrecision));\n        }\n        // Trigger event\n        if (!updateValue.equals(decimalValue.value)) {\n          var _props$onChange;\n          setUncontrolledDecimalValue(updateValue);\n          (_props$onChange = props.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props, updateValue.isEmpty() ? null : getDecimalValue(props.stringMode, updateValue));\n          // Reformat input if value is not controlled\n          if (props.value === undefined) {\n            setInputValue(updateValue, userTyping);\n          }\n        }\n        return updateValue;\n      }\n      return decimalValue.value;\n    };\n    // ========================== User Input ==========================\n    var onNextPromise = useFrame();\n    // >>> Collect input value\n    var collectInputValue = function collectInputValue(inputStr) {\n      var _props$onInput;\n      recordCursor();\n      // Update inputValue incase input can not parse as number\n      inputValue.value = inputStr;\n      // Parse number\n      if (!compositionRef.value) {\n        var finalValue = mergedParser(inputStr);\n        var finalDecimal = getMiniDecimal(finalValue);\n        if (!finalDecimal.isNaN()) {\n          triggerValueUpdate(finalDecimal, true);\n        }\n      }\n      // Trigger onInput later to let user customize value if they want do handle something after onChange\n      (_props$onInput = props.onInput) === null || _props$onInput === void 0 ? void 0 : _props$onInput.call(props, inputStr);\n      // optimize for chinese input experience\n      // https://github.com/ant-design/ant-design/issues/8196\n      onNextPromise(function () {\n        var nextInputStr = inputStr;\n        if (!props.parser) {\n          nextInputStr = inputStr.replace(/。/g, '.');\n        }\n        if (nextInputStr !== inputStr) {\n          collectInputValue(nextInputStr);\n        }\n      });\n    };\n    // >>> Composition\n    var onCompositionStart = function onCompositionStart() {\n      compositionRef.value = true;\n    };\n    var onCompositionEnd = function onCompositionEnd() {\n      compositionRef.value = false;\n      collectInputValue(inputRef.value.value);\n    };\n    // >>> Input\n    var onInternalInput = function onInternalInput(e) {\n      collectInputValue(e.target.value);\n    };\n    // ============================= Step =============================\n    var onInternalStep = function onInternalStep(up) {\n      var _props$onStep, _inputRef$value;\n      // Ignore step since out of range\n      if (up && upDisabled.value || !up && downDisabled.value) {\n        return;\n      }\n      // Clear typing status since it may caused by up & down key.\n      // We should sync with input value.\n      userTypingRef.value = false;\n      var stepDecimal = getMiniDecimal(props.step);\n      if (!up) {\n        stepDecimal = stepDecimal.negate();\n      }\n      var target = (decimalValue.value || getMiniDecimal(0)).add(stepDecimal.toString());\n      var updatedValue = triggerValueUpdate(target, false);\n      (_props$onStep = props.onStep) === null || _props$onStep === void 0 ? void 0 : _props$onStep.call(props, getDecimalValue(props.stringMode, updatedValue), {\n        offset: props.step,\n        type: up ? 'up' : 'down'\n      });\n      (_inputRef$value = inputRef.value) === null || _inputRef$value === void 0 ? void 0 : _inputRef$value.focus();\n    };\n    // ============================ Flush =============================\n    /**\n     * Flush current input content to trigger value change & re-formatter input if needed\n     */\n    var flushInputValue = function flushInputValue(userTyping) {\n      var parsedValue = getMiniDecimal(mergedParser(inputValue.value));\n      var formatValue = parsedValue;\n      if (!parsedValue.isNaN()) {\n        // Only validate value or empty value can be re-fill to inputValue\n        // Reassign the formatValue within ranged of trigger control\n        formatValue = triggerValueUpdate(parsedValue, userTyping);\n      } else {\n        formatValue = decimalValue.value;\n      }\n      if (props.value !== undefined) {\n        // Reset back with controlled value first\n        setInputValue(decimalValue.value, false);\n      } else if (!formatValue.isNaN()) {\n        // Reset input back since no validate value\n        setInputValue(formatValue, false);\n      }\n    };\n    var onKeyDown = function onKeyDown(event) {\n      var which = event.which;\n      userTypingRef.value = true;\n      if (which === KeyCode.ENTER) {\n        var _props$onPressEnter;\n        if (!compositionRef.value) {\n          userTypingRef.value = false;\n        }\n        flushInputValue(false);\n        (_props$onPressEnter = props.onPressEnter) === null || _props$onPressEnter === void 0 ? void 0 : _props$onPressEnter.call(props, event);\n      }\n      if (props.keyboard === false) {\n        return;\n      }\n      // Do step\n      if (!compositionRef.value && [KeyCode.UP, KeyCode.DOWN].includes(which)) {\n        onInternalStep(KeyCode.UP === which);\n        event.preventDefault();\n      }\n    };\n    var onKeyUp = function onKeyUp() {\n      userTypingRef.value = false;\n    };\n    // >>> Focus & Blur\n    var onBlur = function onBlur(e) {\n      flushInputValue(false);\n      focus.value = false;\n      userTypingRef.value = false;\n      emit('blur', e);\n    };\n    // ========================== Controlled ==========================\n    // Input by precision\n    watch(function () {\n      return props.precision;\n    }, function () {\n      if (!decimalValue.value.isInvalidate()) {\n        setInputValue(decimalValue.value, false);\n      }\n    }, {\n      flush: 'post'\n    });\n    // Input by value\n    watch(function () {\n      return props.value;\n    }, function () {\n      var newValue = getMiniDecimal(props.value);\n      decimalValue.value = newValue;\n      var currentParsedValue = getMiniDecimal(mergedParser(inputValue.value));\n      // When user typing from `1.2` to `1.`, we should not convert to `1` immediately.\n      // But let it go if user set `formatter`\n      if (!newValue.equals(currentParsedValue) || !userTypingRef.value || props.formatter) {\n        // Update value as effect\n        setInputValue(newValue, userTypingRef.value);\n      }\n    }, {\n      flush: 'post'\n    });\n    // ============================ Cursor ============================\n    watch(inputValue, function () {\n      if (props.formatter) {\n        restoreCursor();\n      }\n    }, {\n      flush: 'post'\n    });\n    watch(function () {\n      return props.disabled;\n    }, function (val) {\n      if (val) {\n        focus.value = false;\n      }\n    });\n    expose({\n      focus: function focus() {\n        var _inputRef$value2;\n        (_inputRef$value2 = inputRef.value) === null || _inputRef$value2 === void 0 ? void 0 : _inputRef$value2.focus();\n      },\n      blur: function blur() {\n        var _inputRef$value3;\n        (_inputRef$value3 = inputRef.value) === null || _inputRef$value3 === void 0 ? void 0 : _inputRef$value3.blur();\n      }\n    });\n    return function () {\n      var _classNames;\n      var _attrs$props = _objectSpread(_objectSpread({}, attrs), props),\n        _attrs$props$prefixCl = _attrs$props.prefixCls,\n        prefixCls = _attrs$props$prefixCl === void 0 ? 'rc-input-number' : _attrs$props$prefixCl,\n        min = _attrs$props.min,\n        max = _attrs$props.max,\n        _attrs$props$step = _attrs$props.step,\n        step = _attrs$props$step === void 0 ? 1 : _attrs$props$step,\n        defaultValue = _attrs$props.defaultValue,\n        value = _attrs$props.value,\n        disabled = _attrs$props.disabled,\n        readonly = _attrs$props.readonly,\n        keyboard = _attrs$props.keyboard,\n        _attrs$props$controls = _attrs$props.controls,\n        controls = _attrs$props$controls === void 0 ? true : _attrs$props$controls,\n        autofocus = _attrs$props.autofocus,\n        stringMode = _attrs$props.stringMode,\n        parser = _attrs$props.parser,\n        formatter = _attrs$props.formatter,\n        precision = _attrs$props.precision,\n        decimalSeparator = _attrs$props.decimalSeparator,\n        onChange = _attrs$props.onChange,\n        onInput = _attrs$props.onInput,\n        onPressEnter = _attrs$props.onPressEnter,\n        onStep = _attrs$props.onStep,\n        lazy = _attrs$props.lazy,\n        className = _attrs$props.class,\n        style = _attrs$props.style,\n        inputProps = _objectWithoutProperties(_attrs$props, _excluded);\n      var upHandler = slots.upHandler,\n        downHandler = slots.downHandler;\n      var inputClassName = \"\".concat(prefixCls, \"-input\");\n      var eventProps = {};\n      if (lazy) {\n        eventProps.onChange = onInternalInput;\n      } else {\n        eventProps.onInput = onInternalInput;\n      }\n      return _createVNode(\"div\", {\n        \"class\": classNames(prefixCls, className, (_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-focused\"), focus.value), _defineProperty(_classNames, \"\".concat(prefixCls, \"-disabled\"), disabled), _defineProperty(_classNames, \"\".concat(prefixCls, \"-readonly\"), readonly), _defineProperty(_classNames, \"\".concat(prefixCls, \"-not-a-number\"), decimalValue.value.isNaN()), _defineProperty(_classNames, \"\".concat(prefixCls, \"-out-of-range\"), !decimalValue.value.isInvalidate() && !isInRange(decimalValue.value)), _classNames)),\n        \"style\": style,\n        \"onKeydown\": onKeyDown,\n        \"onKeyup\": onKeyUp\n      }, [controls && _createVNode(StepHandler, {\n        \"prefixCls\": prefixCls,\n        \"upDisabled\": upDisabled.value,\n        \"downDisabled\": downDisabled.value,\n        \"onStep\": onInternalStep\n      }, {\n        upNode: upHandler,\n        downNode: downHandler\n      }), _createVNode(\"div\", {\n        \"class\": \"\".concat(inputClassName, \"-wrap\")\n      }, [_createVNode(\"input\", _objectSpread(_objectSpread(_objectSpread({\n        \"autofocus\": autofocus,\n        \"autocomplete\": \"off\",\n        \"role\": \"spinbutton\",\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-valuenow\": decimalValue.value.isInvalidate() ? null : decimalValue.value.toString(),\n        \"step\": step\n      }, inputProps), {}, {\n        \"ref\": inputRef,\n        \"class\": inputClassName,\n        \"value\": inputValue.value,\n        \"disabled\": disabled,\n        \"readonly\": readonly,\n        \"onFocus\": function onFocus(e) {\n          focus.value = true;\n          emit('focus', e);\n        }\n      }, eventProps), {}, {\n        \"onBlur\": onBlur,\n        \"onCompositionstart\": onCompositionStart,\n        \"onCompositionend\": onCompositionEnd\n      }), null)])]);\n    };\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}