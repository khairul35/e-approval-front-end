{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../_util/hooks/useConfigInject';\nimport omit from '../_util/omit';\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\n// Affix\nexport var affixProps = function affixProps() {\n  return {\n    /**\n     * 距离窗口顶部达到指定偏移量后触发\n     */\n    offsetTop: Number,\n    /** 距离窗口底部达到指定偏移量后触发 */\n    offsetBottom: Number,\n    /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n    target: {\n      type: Function,\n      default: getDefaultTarget\n    },\n    prefixCls: String,\n    /** 固定状态改变时触发的回调函数 */\n    onChange: Function,\n    onTestUpdatePosition: Function\n  };\n};\nvar Affix = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'AAffix',\n  props: affixProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n      emit = _ref.emit,\n      expose = _ref.expose;\n    var placeholderNode = ref();\n    var fixedNode = ref();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n    var measure = function measure() {\n      var status = state.status,\n        lastAffix = state.lastAffix;\n      var target = props.target;\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n      var targetNode = target();\n      if (!targetNode) {\n        return;\n      }\n      var newState = {\n        status: AffixStatus.None\n      };\n      var targetRect = getTargetRect(targetNode);\n      var placeholderRect = getTargetRect(placeholderNode.value);\n      var fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderRect.width + 'px',\n          height: placeholderRect.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width + 'px',\n          height: placeholderRect.height + 'px'\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderRect.width + 'px',\n          height: placeholderRect.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width + 'px',\n          height: placeholderRect.height + 'px'\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      }\n      // update state\n      _extends(state, newState);\n    };\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      currentInstance.update();\n      // Test if `updatePosition` called\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle;\n      // Check position change before measure to make Safari smooth\n      if (target && affixStyle) {\n        var targetNode = target();\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderRect = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      }\n      // Directly call prepare measure since it's already throttled.\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance);\n          // Mock Event object.\n          updatePosition();\n        }\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance);\n          // Mock Event object.\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel();\n      // https://github.com/ant-design/ant-design/issues/22683\n      lazyUpdatePosition.cancel();\n    });\n    var _useConfigInject = useConfigInject('affix', props),\n      prefixCls = _useConfigInject.prefixCls;\n    return function () {\n      var _slots$default;\n      var affixStyle = state.affixStyle,\n        placeholderStyle = state.placeholderStyle;\n      var className = classNames(_defineProperty({}, prefixCls.value, affixStyle));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return _createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread({}, restProps), {}, {\n            \"style\": placeholderStyle,\n            \"ref\": placeholderNode\n          }), [_createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])])];\n        }\n      });\n    };\n  }\n});\nexport default withInstall(Affix);","map":{"version":3,"names":["_objectSpread","_defineProperty","_extends","createVNode","_createVNode","defineComponent","ref","reactive","watch","onMounted","getCurrentInstance","computed","onUnmounted","onUpdated","classNames","ResizeObserver","throttleByAnimationFrame","withInstall","addObserveTarget","removeObserveTarget","getTargetRect","getFixedTop","getFixedBottom","useConfigInject","omit","getDefaultTarget","window","AffixStatus","affixProps","offsetTop","Number","offsetBottom","target","type","Function","default","prefixCls","String","onChange","onTestUpdatePosition","Affix","compatConfig","MODE","name","props","setup","_ref","slots","emit","expose","placeholderNode","fixedNode","state","affixStyle","undefined","placeholderStyle","status","None","lastAffix","prevTarget","timeout","currentInstance","measure","Prepare","value","targetNode","newState","targetRect","placeholderRect","fixedTop","fixedBottom","position","top","width","height","bottom","prepareMeasure","update","process","env","NODE_ENV","updatePosition","lazyUpdatePosition","val","newTarget","setTimeout","clearTimeout","cancel","_useConfigInject","_slots$default","className","restProps","_default","call"],"sources":["/Users/dev/e-approver/node_modules/ant-design-vue/es/affix/index.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../_util/hooks/useConfigInject';\nimport omit from '../_util/omit';\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nvar AffixStatus;\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {}));\n// Affix\nexport var affixProps = function affixProps() {\n  return {\n    /**\n     * 距离窗口顶部达到指定偏移量后触发\n     */\n    offsetTop: Number,\n    /** 距离窗口底部达到指定偏移量后触发 */\n    offsetBottom: Number,\n    /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n    target: {\n      type: Function,\n      default: getDefaultTarget\n    },\n    prefixCls: String,\n    /** 固定状态改变时触发的回调函数 */\n    onChange: Function,\n    onTestUpdatePosition: Function\n  };\n};\nvar Affix = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'AAffix',\n  props: affixProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n      emit = _ref.emit,\n      expose = _ref.expose;\n    var placeholderNode = ref();\n    var fixedNode = ref();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n    var measure = function measure() {\n      var status = state.status,\n        lastAffix = state.lastAffix;\n      var target = props.target;\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n      var targetNode = target();\n      if (!targetNode) {\n        return;\n      }\n      var newState = {\n        status: AffixStatus.None\n      };\n      var targetRect = getTargetRect(targetNode);\n      var placeholderRect = getTargetRect(placeholderNode.value);\n      var fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderRect.width + 'px',\n          height: placeholderRect.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width + 'px',\n          height: placeholderRect.height + 'px'\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderRect.width + 'px',\n          height: placeholderRect.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width + 'px',\n          height: placeholderRect.height + 'px'\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      }\n      // update state\n      _extends(state, newState);\n    };\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n      currentInstance.update();\n      // Test if `updatePosition` called\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle;\n      // Check position change before measure to make Safari smooth\n      if (target && affixStyle) {\n        var targetNode = target();\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderRect = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderRect, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom.value);\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      }\n      // Directly call prepare measure since it's already throttled.\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance);\n          // Mock Event object.\n          updatePosition();\n        }\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance);\n          // Mock Event object.\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel();\n      // https://github.com/ant-design/ant-design/issues/22683\n      lazyUpdatePosition.cancel();\n    });\n    var _useConfigInject = useConfigInject('affix', props),\n      prefixCls = _useConfigInject.prefixCls;\n    return function () {\n      var _slots$default;\n      var affixStyle = state.affixStyle,\n        placeholderStyle = state.placeholderStyle;\n      var className = classNames(_defineProperty({}, prefixCls.value, affixStyle));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return _createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread({}, restProps), {}, {\n            \"style\": placeholderStyle,\n            \"ref\": placeholderNode\n          }), [_createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])])];\n        }\n      });\n    };\n  }\n});\nexport default withInstall(Affix);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}