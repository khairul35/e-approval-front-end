{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport { createVNode as _createVNode } from \"vue\";\nimport classNames from '../../_util/classNames';\nimport PropTypes, { withUndefined } from '../../_util/vue-types';\nimport BaseMixin from '../../_util/BaseMixin';\nimport { hasProp } from '../../_util/props-util';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\nimport initDefaultProps from '../../_util/props-util/initDefaultProps';\nimport { defineComponent } from 'vue';\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n    handle = _ref.handle,\n    bounds = _ref.bounds,\n    props = _ref.props;\n  var allowCross = props.allowCross,\n    pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\nvar rangeProps = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: Number,\n  pushable: withUndefined(PropTypes.oneOfType([PropTypes.looseBool, PropTypes.number])),\n  allowCross: {\n    type: Boolean,\n    default: undefined\n  },\n  disabled: {\n    type: Boolean,\n    default: undefined\n  },\n  reverse: {\n    type: Boolean,\n    default: undefined\n  },\n  tabindex: PropTypes.arrayOf(PropTypes.number),\n  prefixCls: String,\n  min: Number,\n  max: Number,\n  autofocus: {\n    type: Boolean,\n    default: undefined\n  },\n  ariaLabelGroupForHandles: Array,\n  ariaLabelledByGroupForHandles: Array,\n  ariaValueTextFormatterGroupForHandles: Array,\n  draggableTrack: {\n    type: Boolean,\n    default: undefined\n  }\n};\nvar Range = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'Range',\n  mixins: [BaseMixin],\n  inheritAttrs: false,\n  props: initDefaultProps(rangeProps, {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabindex: [],\n    draggableTrack: false,\n    ariaLabelGroupForHandles: [],\n    ariaLabelledByGroupForHandles: [],\n    ariaValueTextFormatterGroupForHandles: []\n  }),\n  emits: ['beforeChange', 'afterChange', 'change'],\n  displayName: 'Range',\n  data: function data() {\n    var _this = this;\n    var count = this.count,\n      min = this.min,\n      max = this.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = hasProp(this, 'defaultValue') ? this.defaultValue : initialValue;\n    var value = this.value;\n    if (value === undefined) {\n      value = defaultValue;\n    }\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: _this.$props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    return {\n      sHandle: null,\n      recent: recent,\n      bounds: bounds\n    };\n  },\n  watch: {\n    value: {\n      handler: function handler(val) {\n        var bounds = this.bounds;\n        this.setChangeValue(val || bounds);\n      },\n      deep: true\n    },\n    min: function min() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    },\n    max: function max() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    }\n  },\n  methods: {\n    setChangeValue: function setChangeValue(value) {\n      var _this2 = this;\n      var bounds = this.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: bounds,\n          props: _this2.$props\n        });\n      });\n      if (bounds.length === nextBounds.length) {\n        if (nextBounds.every(function (v, i) {\n          return v === bounds[i];\n        })) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            props: _this2.$props\n          });\n        });\n      }\n      this.setState({\n        bounds: nextBounds\n      });\n      if (value.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.$props);\n      })) {\n        var newValues = value.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.$props);\n        });\n        this.$emit('change', newValues);\n      }\n    },\n    onChange: function onChange(state) {\n      var isNotControlled = !hasProp(this, 'value');\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['sHandle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n      var data = _objectSpread(_objectSpread({}, this.$data), state);\n      var changedValue = data.bounds;\n      this.$emit('change', changedValue);\n    },\n    positionGetValue: function positionGetValue(position) {\n      var bounds = this.getValue();\n      var value = this.calcValueByPos(position);\n      var closestBound = this.getClosestBound(value);\n      var index = this.getBoundNeedMoving(value, closestBound);\n      var prevValue = bounds[index];\n      if (value === prevValue) return null;\n      var nextBounds = _toConsumableArray(bounds);\n      nextBounds[index] = value;\n      return nextBounds;\n    },\n    onStart: function onStart(position) {\n      var bounds = this.bounds;\n      this.$emit('beforeChange', bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        sHandle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n      var nextBounds = _toConsumableArray(bounds);\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    },\n    onEnd: function onEnd(force) {\n      var sHandle = this.sHandle;\n      this.removeDocumentEvents();\n      if (!sHandle) {\n        this.dragTrack = false;\n      }\n      if (sHandle !== null || force) {\n        this.$emit('afterChange', this.bounds);\n      }\n      this.setState({\n        sHandle: null\n      });\n    },\n    onMove: function onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      var state = this.$data,\n        props = this.$props;\n      var maxValue = props.max || 100;\n      var minValue = props.min || 0;\n      if (dragTrack) {\n        var pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        var max = maxValue - Math.max.apply(Math, _toConsumableArray(startBounds));\n        var min = minValue - Math.min.apply(Math, _toConsumableArray(startBounds));\n        var ratio = Math.min(Math.max(pos / (this.getSliderLength() / 100), min), max);\n        var nextBounds = startBounds.map(function (v) {\n          return Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue));\n        });\n        if (state.bounds.map(function (c, i) {\n          return c === nextBounds[i];\n        }).some(function (c) {\n          return !c;\n        })) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n        return;\n      }\n      var bounds = this.bounds,\n        sHandle = this.sHandle;\n      var value = this.calcValueByPos(position);\n      var oldValue = bounds[sHandle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    },\n    onKeyboard: function onKeyboard(e) {\n      var _this$$props = this.$props,\n        reverse = _this$$props.reverse,\n        vertical = _this$$props.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var bounds = this.bounds,\n          sHandle = this.sHandle;\n        var oldValue = bounds[sHandle === null ? this.recent : sHandle];\n        var mutatedValue = valueMutator(oldValue, this.$props);\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: sHandle,\n          bounds: bounds,\n          props: this.$props\n        });\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    },\n    getClosestBound: function getClosestBound(value) {\n      var bounds = this.bounds;\n      var closestBound = 0;\n      for (var i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n      return closestBound;\n    },\n    getBoundNeedMoving: function getBoundNeedMoving(value, closestBound) {\n      var bounds = this.bounds,\n        recent = this.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n      return boundNeedMoving;\n    },\n    getLowerBound: function getLowerBound() {\n      return this.bounds[0];\n    },\n    getUpperBound: function getUpperBound() {\n      var bounds = this.bounds;\n      return bounds[bounds.length - 1];\n    },\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n    getPoints: function getPoints() {\n      var marks = this.marks,\n        step = this.step,\n        min = this.min,\n        max = this.max;\n      var cache = this.internalPointsCache;\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _objectSpread({}, marks);\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this.internalPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n      return this.internalPointsCache.points;\n    },\n    moveTo: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n      var nextBounds = _toConsumableArray(this.bounds);\n      var sHandle = this.sHandle,\n        recent = this.recent;\n      var handle = sHandle === null ? recent : sHandle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n      if (this.$props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (this.$props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n      this.onChange({\n        recent: nextHandle,\n        sHandle: nextHandle,\n        bounds: nextBounds\n      });\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.$emit('afterChange', nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    },\n    pushSurroundingHandles: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var pushable = this.pushable;\n      var threshold = Number(pushable);\n      var direction = 0;\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    },\n    pushHandle: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n        currentValue = bounds[handle];\n      }\n      // the handle was pushed enough to create the needed `amount` gap\n      return true;\n    },\n    pushHandleOnePoint: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var pushable = this.pushable;\n      var threshold = Number(pushable);\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      }\n      // push the handle\n      bounds[handle] = nextValue;\n      return true;\n    },\n    trimAlignValue: function trimAlignValue(value) {\n      var sHandle = this.sHandle,\n        bounds = this.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: sHandle,\n        bounds: bounds,\n        props: this.$props\n      });\n    },\n    ensureValueNotConflict: function ensureValueNotConflict(handle, val, _ref2) {\n      var allowCross = _ref2.allowCross,\n        thershold = _ref2.pushable;\n      var state = this.$data || {};\n      var bounds = state.bounds;\n      handle = handle === undefined ? state.sHandle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n      return val;\n    },\n    getTrack: function getTrack(_ref3) {\n      var bounds = _ref3.bounds,\n        prefixCls = _ref3.prefixCls,\n        reverse = _ref3.reverse,\n        vertical = _ref3.vertical,\n        included = _ref3.included,\n        offsets = _ref3.offsets,\n        trackStyle = _ref3.trackStyle;\n      return bounds.slice(0, -1).map(function (_, index) {\n        var _classNames;\n        var i = index + 1;\n        var trackClassName = classNames((_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames));\n        return _createVNode(Track, {\n          \"class\": trackClassName,\n          \"vertical\": vertical,\n          \"reverse\": reverse,\n          \"included\": included,\n          \"offset\": offsets[i - 1],\n          \"length\": offsets[i] - offsets[i - 1],\n          \"style\": trackStyle[index],\n          \"key\": i\n        }, null);\n      });\n    },\n    renderSlider: function renderSlider() {\n      var _this4 = this;\n      var sHandle = this.sHandle,\n        bounds = this.bounds,\n        prefixCls = this.prefixCls,\n        vertical = this.vertical,\n        included = this.included,\n        disabled = this.disabled,\n        min = this.min,\n        max = this.max,\n        reverse = this.reverse,\n        handle = this.handle,\n        defaultHandle = this.defaultHandle,\n        trackStyle = this.trackStyle,\n        handleStyle = this.handleStyle,\n        tabindex = this.tabindex,\n        ariaLabelGroupForHandles = this.ariaLabelGroupForHandles,\n        ariaLabelledByGroupForHandles = this.ariaLabelledByGroupForHandles,\n        ariaValueTextFormatterGroupForHandles = this.ariaValueTextFormatterGroupForHandles;\n      var handleGenerator = handle || defaultHandle;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames2;\n        var mergedTabIndex = tabindex[i] || 0;\n        if (disabled || tabindex[i] === null) {\n          mergedTabIndex = null;\n        }\n        var dragging = sHandle === i;\n        return handleGenerator({\n          class: classNames((_classNames2 = {}, _defineProperty(_classNames2, handleClassName, true), _defineProperty(_classNames2, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames2, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames2)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          dragging: dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabindex: mergedTabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          onFocus: _this4.onFocus,\n          onBlur: _this4.onBlur,\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      return {\n        tracks: this.getTrack({\n          bounds: bounds,\n          prefixCls: prefixCls,\n          reverse: reverse,\n          vertical: vertical,\n          included: included,\n          offsets: offsets,\n          trackStyle: trackStyle\n        }),\n        handles: handles\n      };\n    }\n  }\n});\nexport default createSlider(Range);","map":{"version":3,"names":["_defineProperty","_objectSpread","_toConsumableArray","createVNode","_createVNode","classNames","PropTypes","withUndefined","BaseMixin","hasProp","Track","createSlider","utils","initDefaultProps","defineComponent","_trimAlignValue","trimAlignValue","_ref","value","handle","bounds","props","allowCross","pushable","thershold","Number","valInRange","ensureValueInRange","valNotConflict","undefined","length","ensureValuePrecision","rangeProps","defaultValue","arrayOf","number","count","oneOfType","looseBool","type","Boolean","default","disabled","reverse","tabindex","prefixCls","String","min","max","autofocus","ariaLabelGroupForHandles","Array","ariaLabelledByGroupForHandles","ariaValueTextFormatterGroupForHandles","draggableTrack","Range","compatConfig","MODE","name","mixins","inheritAttrs","emits","displayName","data","_this","initialValue","apply","map","v","i","$props","recent","sHandle","watch","handler","val","setChangeValue","deep","methods","_this2","nextBounds","every","setState","some","isValueOutOfRange","newValues","$emit","onChange","state","isNotControlled","controlledState","forEach","item","Object","keys","$data","changedValue","positionGetValue","position","getValue","calcValueByPos","closestBound","getClosestBound","index","getBoundNeedMoving","prevValue","onStart","startValue","startPosition","prevMovedHandleIndex","onEnd","force","removeDocumentEvents","dragTrack","onMove","e","startBounds","pauseEvent","maxValue","minValue","pos","vertical","Math","ratio","getSliderLength","floor","c","oldValue","moveTo","onKeyboard","_this$$props","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","abs","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","marks","step","cache","internalPointsCache","pointsObject","point","points","parseFloat","sort","a","b","_this3","nextHandle","pushSurroundingHandles","indexOf","handlesRefs","focus","threshold","direction","diffToNext","pushHandle","amount","originalValue","currentValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","ensureValueNotConflict","_ref2","getTrack","_ref3","included","offsets","trackStyle","slice","_","_classNames","trackClassName","concat","renderSlider","_this4","defaultHandle","handleStyle","handleGenerator","calcOffset","handleClassName","handles","_classNames2","mergedTabIndex","dragging","class","offset","style","ref","h","saveHandle","onFocus","onBlur","ariaLabel","ariaLabelledBy","ariaValueTextFormatter","tracks"],"sources":["/Users/dev/e-approver/node_modules/ant-design-vue/es/vc-slider/src/Range.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport { createVNode as _createVNode } from \"vue\";\nimport classNames from '../../_util/classNames';\nimport PropTypes, { withUndefined } from '../../_util/vue-types';\nimport BaseMixin from '../../_util/BaseMixin';\nimport { hasProp } from '../../_util/props-util';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\nimport initDefaultProps from '../../_util/props-util/initDefaultProps';\nimport { defineComponent } from 'vue';\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n    handle = _ref.handle,\n    bounds = _ref.bounds,\n    props = _ref.props;\n  var allowCross = props.allowCross,\n    pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\nvar rangeProps = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: Number,\n  pushable: withUndefined(PropTypes.oneOfType([PropTypes.looseBool, PropTypes.number])),\n  allowCross: {\n    type: Boolean,\n    default: undefined\n  },\n  disabled: {\n    type: Boolean,\n    default: undefined\n  },\n  reverse: {\n    type: Boolean,\n    default: undefined\n  },\n  tabindex: PropTypes.arrayOf(PropTypes.number),\n  prefixCls: String,\n  min: Number,\n  max: Number,\n  autofocus: {\n    type: Boolean,\n    default: undefined\n  },\n  ariaLabelGroupForHandles: Array,\n  ariaLabelledByGroupForHandles: Array,\n  ariaValueTextFormatterGroupForHandles: Array,\n  draggableTrack: {\n    type: Boolean,\n    default: undefined\n  }\n};\nvar Range = defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'Range',\n  mixins: [BaseMixin],\n  inheritAttrs: false,\n  props: initDefaultProps(rangeProps, {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabindex: [],\n    draggableTrack: false,\n    ariaLabelGroupForHandles: [],\n    ariaLabelledByGroupForHandles: [],\n    ariaValueTextFormatterGroupForHandles: []\n  }),\n  emits: ['beforeChange', 'afterChange', 'change'],\n  displayName: 'Range',\n  data: function data() {\n    var _this = this;\n    var count = this.count,\n      min = this.min,\n      max = this.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = hasProp(this, 'defaultValue') ? this.defaultValue : initialValue;\n    var value = this.value;\n    if (value === undefined) {\n      value = defaultValue;\n    }\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: _this.$props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    return {\n      sHandle: null,\n      recent: recent,\n      bounds: bounds\n    };\n  },\n  watch: {\n    value: {\n      handler: function handler(val) {\n        var bounds = this.bounds;\n        this.setChangeValue(val || bounds);\n      },\n      deep: true\n    },\n    min: function min() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    },\n    max: function max() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    }\n  },\n  methods: {\n    setChangeValue: function setChangeValue(value) {\n      var _this2 = this;\n      var bounds = this.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: bounds,\n          props: _this2.$props\n        });\n      });\n      if (bounds.length === nextBounds.length) {\n        if (nextBounds.every(function (v, i) {\n          return v === bounds[i];\n        })) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            props: _this2.$props\n          });\n        });\n      }\n      this.setState({\n        bounds: nextBounds\n      });\n      if (value.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.$props);\n      })) {\n        var newValues = value.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.$props);\n        });\n        this.$emit('change', newValues);\n      }\n    },\n    onChange: function onChange(state) {\n      var isNotControlled = !hasProp(this, 'value');\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['sHandle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n      var data = _objectSpread(_objectSpread({}, this.$data), state);\n      var changedValue = data.bounds;\n      this.$emit('change', changedValue);\n    },\n    positionGetValue: function positionGetValue(position) {\n      var bounds = this.getValue();\n      var value = this.calcValueByPos(position);\n      var closestBound = this.getClosestBound(value);\n      var index = this.getBoundNeedMoving(value, closestBound);\n      var prevValue = bounds[index];\n      if (value === prevValue) return null;\n      var nextBounds = _toConsumableArray(bounds);\n      nextBounds[index] = value;\n      return nextBounds;\n    },\n    onStart: function onStart(position) {\n      var bounds = this.bounds;\n      this.$emit('beforeChange', bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        sHandle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n      var nextBounds = _toConsumableArray(bounds);\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    },\n    onEnd: function onEnd(force) {\n      var sHandle = this.sHandle;\n      this.removeDocumentEvents();\n      if (!sHandle) {\n        this.dragTrack = false;\n      }\n      if (sHandle !== null || force) {\n        this.$emit('afterChange', this.bounds);\n      }\n      this.setState({\n        sHandle: null\n      });\n    },\n    onMove: function onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      var state = this.$data,\n        props = this.$props;\n      var maxValue = props.max || 100;\n      var minValue = props.min || 0;\n      if (dragTrack) {\n        var pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        var max = maxValue - Math.max.apply(Math, _toConsumableArray(startBounds));\n        var min = minValue - Math.min.apply(Math, _toConsumableArray(startBounds));\n        var ratio = Math.min(Math.max(pos / (this.getSliderLength() / 100), min), max);\n        var nextBounds = startBounds.map(function (v) {\n          return Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue));\n        });\n        if (state.bounds.map(function (c, i) {\n          return c === nextBounds[i];\n        }).some(function (c) {\n          return !c;\n        })) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n        return;\n      }\n      var bounds = this.bounds,\n        sHandle = this.sHandle;\n      var value = this.calcValueByPos(position);\n      var oldValue = bounds[sHandle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    },\n    onKeyboard: function onKeyboard(e) {\n      var _this$$props = this.$props,\n        reverse = _this$$props.reverse,\n        vertical = _this$$props.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var bounds = this.bounds,\n          sHandle = this.sHandle;\n        var oldValue = bounds[sHandle === null ? this.recent : sHandle];\n        var mutatedValue = valueMutator(oldValue, this.$props);\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: sHandle,\n          bounds: bounds,\n          props: this.$props\n        });\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    },\n    getClosestBound: function getClosestBound(value) {\n      var bounds = this.bounds;\n      var closestBound = 0;\n      for (var i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n      return closestBound;\n    },\n    getBoundNeedMoving: function getBoundNeedMoving(value, closestBound) {\n      var bounds = this.bounds,\n        recent = this.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n      return boundNeedMoving;\n    },\n    getLowerBound: function getLowerBound() {\n      return this.bounds[0];\n    },\n    getUpperBound: function getUpperBound() {\n      var bounds = this.bounds;\n      return bounds[bounds.length - 1];\n    },\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n    getPoints: function getPoints() {\n      var marks = this.marks,\n        step = this.step,\n        min = this.min,\n        max = this.max;\n      var cache = this.internalPointsCache;\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _objectSpread({}, marks);\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this.internalPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n      return this.internalPointsCache.points;\n    },\n    moveTo: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n      var nextBounds = _toConsumableArray(this.bounds);\n      var sHandle = this.sHandle,\n        recent = this.recent;\n      var handle = sHandle === null ? recent : sHandle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n      if (this.$props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (this.$props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n      this.onChange({\n        recent: nextHandle,\n        sHandle: nextHandle,\n        bounds: nextBounds\n      });\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.$emit('afterChange', nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    },\n    pushSurroundingHandles: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var pushable = this.pushable;\n      var threshold = Number(pushable);\n      var direction = 0;\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    },\n    pushHandle: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n        currentValue = bounds[handle];\n      }\n      // the handle was pushed enough to create the needed `amount` gap\n      return true;\n    },\n    pushHandleOnePoint: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var pushable = this.pushable;\n      var threshold = Number(pushable);\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      }\n      // push the handle\n      bounds[handle] = nextValue;\n      return true;\n    },\n    trimAlignValue: function trimAlignValue(value) {\n      var sHandle = this.sHandle,\n        bounds = this.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: sHandle,\n        bounds: bounds,\n        props: this.$props\n      });\n    },\n    ensureValueNotConflict: function ensureValueNotConflict(handle, val, _ref2) {\n      var allowCross = _ref2.allowCross,\n        thershold = _ref2.pushable;\n      var state = this.$data || {};\n      var bounds = state.bounds;\n      handle = handle === undefined ? state.sHandle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n      return val;\n    },\n    getTrack: function getTrack(_ref3) {\n      var bounds = _ref3.bounds,\n        prefixCls = _ref3.prefixCls,\n        reverse = _ref3.reverse,\n        vertical = _ref3.vertical,\n        included = _ref3.included,\n        offsets = _ref3.offsets,\n        trackStyle = _ref3.trackStyle;\n      return bounds.slice(0, -1).map(function (_, index) {\n        var _classNames;\n        var i = index + 1;\n        var trackClassName = classNames((_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames));\n        return _createVNode(Track, {\n          \"class\": trackClassName,\n          \"vertical\": vertical,\n          \"reverse\": reverse,\n          \"included\": included,\n          \"offset\": offsets[i - 1],\n          \"length\": offsets[i] - offsets[i - 1],\n          \"style\": trackStyle[index],\n          \"key\": i\n        }, null);\n      });\n    },\n    renderSlider: function renderSlider() {\n      var _this4 = this;\n      var sHandle = this.sHandle,\n        bounds = this.bounds,\n        prefixCls = this.prefixCls,\n        vertical = this.vertical,\n        included = this.included,\n        disabled = this.disabled,\n        min = this.min,\n        max = this.max,\n        reverse = this.reverse,\n        handle = this.handle,\n        defaultHandle = this.defaultHandle,\n        trackStyle = this.trackStyle,\n        handleStyle = this.handleStyle,\n        tabindex = this.tabindex,\n        ariaLabelGroupForHandles = this.ariaLabelGroupForHandles,\n        ariaLabelledByGroupForHandles = this.ariaLabelledByGroupForHandles,\n        ariaValueTextFormatterGroupForHandles = this.ariaValueTextFormatterGroupForHandles;\n      var handleGenerator = handle || defaultHandle;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames2;\n        var mergedTabIndex = tabindex[i] || 0;\n        if (disabled || tabindex[i] === null) {\n          mergedTabIndex = null;\n        }\n        var dragging = sHandle === i;\n        return handleGenerator({\n          class: classNames((_classNames2 = {}, _defineProperty(_classNames2, handleClassName, true), _defineProperty(_classNames2, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames2, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames2)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          dragging: dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabindex: mergedTabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          onFocus: _this4.onFocus,\n          onBlur: _this4.onBlur,\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      return {\n        tracks: this.getTrack({\n          bounds: bounds,\n          prefixCls: prefixCls,\n          reverse: reverse,\n          vertical: vertical,\n          included: included,\n          offsets: offsets,\n          trackStyle: trackStyle\n        }),\n        handles: handles\n      };\n    }\n  }\n});\nexport default createSlider(Range);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}